void Overseer::mainLoop()
{
    socklen_t               addr_size;
    int                     new_fd;
    struct sockaddr_storage their_addr;
    char hostname[100];
    size_t size = sizeof(hostname); 



    int fd_count = 0;
    int fd_size = 5;

    //Get a stfuct for my polls, they are init to fd_size (arbitrary)
    std::vector<struct pollfd *>  pfds(fd_size);


    gethostname(hostname, size);

    std::cout <<  "my domain: "<< hostname << std::endl;

    std::cout << "server: waiting for connections..." << std::endl;

    while (1)
    {
        addr_size = sizeof (their_addr);
        new_fd = accept(server.getSocket(), (struct sockaddr *)&their_addr, &addr_size);
        if (new_fd == -1) {
            perror("accept");
            continue;
        }

        // inet_ntop(their_addr.ss_family,
        //     get_in_addr((struct sockaddr *)&their_addr),
        //     s, sizeof s);
        // printf("server: got connection from %s\n", s);

        if (!fork()) 
        { // this is the child process
            close(server.getSocket()); // child doesn't need the listener
            /*once we have a connection, curl sends a http/1.1 request, we should parse it, check it's correct and send correct respose*/
            /*running curl -X POST sends a post request*/
            char msg[10000];
            recv(new_fd, msg, sizeof(msg), 0);
            std::cout << msg << std::endl;

            std::string http = "HTTP/1.1 200 OK\r\n"
                     "Content-Type: text/plain\r\n"
                     "Content-Length: 13\r\n"
                     "\r\n"
                     "Hello, world!\r\n";

            if (send(new_fd, http.c_str(), std::strlen(http.c_str()), 0) == -1)
                perror("send");
            close(new_fd);
            exit(0);
        }
        close(new_fd);  // parent doesn't need this
    }
    close(server.getSocket());
}